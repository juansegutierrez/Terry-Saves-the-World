<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Terry Saves the World - Mobile Edition</title>
    <style>
        /* CSS: The "Office Aesthetic" Stylesheet */
        :root {
            --bg-teal: #008080;
            --win-gray: #c0c0c0;
            --win-blue: #000080;
            --win-white: #ffffff;
            --win-dark: #808080;
            --win-black: #000000;
        }

        body {
            background-color: var(--bg-teal);
            font-family: 'Courier New', Courier, monospace;
            margin: 0;
            height: 100vh;
            height: 100dvh; /* Dynamic Viewport Height for mobile browsers */
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            user-select: none;
            touch-action: none; /* Prevent browser zooming/scrolling */
        }

        #app-container {
            width: 100%;
            max-width: 500px; /* Kept narrow for phone screens */
            height: 100%;
            max-height: 850px;
            background-color: var(--win-gray);
            border: 2px solid var(--win-white);
            box-shadow: 8px 8px 0px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            padding: 2px; /* Reduced padding */
            box-sizing: border-box;
        }

        /* Title Bar */
        .title-bar {
            background-color: var(--win-blue);
            color: var(--win-white);
            padding: 4px 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            letter-spacing: 1px;
            margin-bottom: 4px;
            font-size: 14px;
            flex-shrink: 0;
        }

        .title-btn {
            background: var(--win-gray);
            color: black;
            border: 1px outset white;
            width: 24px;
            height: 24px;
            text-align: center;
            line-height: 22px;
            cursor: pointer;
        }

        /* Dialogue Section */
        #dialogue-area {
            background: white;
            border: 2px inset var(--win-dark);
            height: 50px; /* Reduced height */
            padding: 6px;
            margin-bottom: 6px;
            font-size: 12px;
            line-height: 1.3;
            overflow-y: auto;
            color: black;
            flex-shrink: 0;
        }

        .speaker-zeke { color: #800000; font-weight: bold; }
        .speaker-terry { color: #000080; font-weight: bold; }
        .speaker-sys { color: #008000; font-weight: bold; }

        /* Canvas Wrapper */
        #canvas-wrapper {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: var(--win-gray);
            border: 3px groove var(--win-white);
            padding: 2px;
            overflow: hidden;
            position: relative;
        }

        canvas {
            background-color: #c0c0c0;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        /* Status Bar */
        .status-bar {
            margin-top: 6px;
            border-top: 1px solid var(--win-dark);
            border-bottom: 1px solid var(--win-white);
            padding: 4px;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            background: var(--win-gray);
        }

        /* Mobile Controls */
        .mobile-controls {
            display: flex;
            gap: 10px;
            margin-top: 4px;
            justify-content: center;
            flex-shrink: 0;
        }

        .mode-btn {
            background: var(--win-gray);
            border: 2px outset var(--win-white);
            padding: 6px 12px;
            font-family: 'Courier New', Courier, monospace;
            font-weight: bold;
            font-size: 12px;
            cursor: pointer;
            width: 140px;
        }
        
        .mode-btn.active {
            background: #e0e0e0;
            border: 2px inset var(--win-dark);
            color: #000080;
        }

        .credits {
            text-align: right;
            font-size: 9px;
            color: #555;
            margin-top: 2px;
            font-style: italic;
        }
    </style>
</head>
<body>

    <div id="app-container">
        <!-- Title Bar -->
        <div class="title-bar">
            <span>TERRY_SAVES_WORLD</span>
            <div class="title-btn" onclick="game.hardReset()">R</div>
        </div>

        <!-- Narrative Output -->
        <div id="dialogue-area">
            <span class="speaker-sys">SYSTEM:</span> "Initializing mobile interface... Long press to flag hazards."
        </div>

        <!-- Game Viewport -->
        <div id="canvas-wrapper">
            <canvas id="gameCanvas" width="600" height="600"></canvas>
        </div>

        <!-- Mobile-Friendly Controls -->
        <div class="mobile-controls">
            <button id="mode-toggle" class="mode-btn" onclick="game.toggleMode()">MODE: DISARM</button>
        </div>

        <!-- Status & Stats -->
        <div class="status-bar">
            <span id="level-display">LVL: 1/3</span>
            <span id="mines-left">HAZARDS: --</span>
        </div>
        
        <div class="credits">Long Press to Flag | A game by Juan S. Gutierrez.</div>
    </div>

<script>
/**
 * TERRY SAVES THE WORLD - V2.1 (Long Press & Saves)
 * Lead Dev: Bob
 * Patch Notes: 
 * - Implemented localStorage for job security.
 * - Added long-press gesture for flagging.
 * - Adjusted mobile viewport layout.
 */

class GameEngine {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.dialogueEl = document.getElementById('dialogue-area');
        this.minesLeftEl = document.getElementById('mines-left');
        this.levelDisplayEl = document.getElementById('level-display');
        this.modeBtn = document.getElementById('mode-toggle');
        
        // Level Configuration
        this.levels = [
            { level: 1, size: 8, mines: 10, name: "CUBICLE", zekeIntro: "Pathetic. You can't even clear your own desk." },
            { level: 2, size: 10, mines: 15, name: "BREAKROOM", zekeIntro: "I've booby-trapped the donuts, Terry! Give up!" },
            { level: 3, size: 12, mines: 25, name: "MOTHERSHIP", zekeIntro: "Welcome to my office. The gravity is weird and the rent is terrible." }
        ];
        
        this.currentLevelIdx = 0;
        this.colors = [null, 'blue', 'green', 'red', 'purple', 'maroon', 'turquoise', 'black', 'gray'];

        // State
        this.grid = [];
        this.gameState = 'INTRO'; // INTRO, PLAYING, LEVEL_COMPLETE, VICTORY, GAMEOVER
        this.firstClick = true;
        this.flagsPlaced = 0;
        this.inputMode = 'DISARM'; // 'DISARM' or 'FLAG'
        this.confettiParticles = [];
        this.animationFrameId = null;

        // Long Press State
        this.longPressTimer = null;
        this.isLongPress = false;
        this.touchStartTime = 0;
        this.lastTouchX = null;
        this.lastTouchY = null;

        // Load Save Data
        this.loadProgress();

        // Input Bindings
        this.setupInputs();

        // Start
        this.startIntro();
    }

    loadProgress() {
        const savedLevel = localStorage.getItem('terry_max_level');
        if (savedLevel) {
            const levelIdx = parseInt(savedLevel, 10);
            if (!isNaN(levelIdx) && levelIdx >= 0 && levelIdx < this.levels.length) {
                this.currentLevelIdx = levelIdx;
            }
        }
    }

    saveProgress() {
        localStorage.setItem('terry_max_level', this.currentLevelIdx);
    }

    setupInputs() {
        // Mouse
        this.canvas.addEventListener('mousedown', (e) => this.handleMouse(e));
        this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // Touch with Long Press Logic
        this.canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            this.handleTouchStart(touch.clientX, touch.clientY);
        }, { passive: false });

        this.canvas.addEventListener('touchend', (e) => {
            e.preventDefault(); // Prevent ghost clicks
            this.handleTouchEnd(e);
        }, { passive: false });

        this.canvas.addEventListener('touchmove', (e) => {
            // Cancel long press if finger moves too much
            clearTimeout(this.longPressTimer);
            this.longPressTimer = null;
        }, { passive: false });
    }

    // --- INPUT HANDLING ---

    handleTouchStart(x, y) {
        this.isLongPress = false;
        this.lastTouchX = x;
        this.lastTouchY = y;
        
        // Only enable long press detection if we are actually playing
        if (this.gameState === 'PLAYING') {
            // Start Timer (500ms for long press)
            this.longPressTimer = setTimeout(() => {
                this.isLongPress = true;
                this.handleInput(x, y, true); // Trigger right-click/flag logic
                
                // Visual feedback (Vibrate if supported)
                if (navigator.vibrate) navigator.vibrate(50);
            }, 300);
        }
    }

    handleTouchEnd(e) {
        clearTimeout(this.longPressTimer); // Cancel timer if released early
        
        if (this.isLongPress) {
            // Already handled by timer, do nothing
            this.isLongPress = false; 
            return;
        }

        // If not a long press, handle as normal tap
        if (this.lastTouchX !== null) {
            this.handleInput(this.lastTouchX, this.lastTouchY, false);
        }
        
        this.lastTouchX = null;
        this.lastTouchY = null;
    }

    handleMouse(e) {
        if (e.button === 2) { // Right Click always flags
            this.handleInput(e.clientX, e.clientY, true);
        } else {
            this.handleInput(e.clientX, e.clientY, false);
        }
    }

    handleInput(clientX, clientY, isRightClick) {
        if (this.gameState === 'INTRO') {
            this.startLevel(this.currentLevelIdx); // Resume from saved level
            return;
        }

        if (this.gameState === 'LEVEL_COMPLETE') {
            this.currentLevelIdx++;
            this.saveProgress();
            this.startLevel(this.currentLevelIdx);
            return;
        }

        if (this.gameState === 'GAMEOVER') {
            // Retry Current Level logic
            this.startLevel(this.currentLevelIdx);
            return;
        }

        if (this.gameState === 'VICTORY') {
            // Reset to 0 after winning game
            this.currentLevelIdx = 0;
            this.saveProgress();
            this.startIntro();
            return;
        }

        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;

        const x = (clientX - rect.left) * scaleX;
        const y = (clientY - rect.top) * scaleY;

        const c = Math.floor(x / this.CELL_SIZE);
        const r = Math.floor(y / this.CELL_SIZE);

        if (r >= 0 && r < this.GRID_SIZE && c >= 0 && c < this.GRID_SIZE) {
            // Determine action based on Mode OR Right Click OR Long Press
            const isFlagAction = isRightClick || (this.inputMode === 'FLAG');

            if (isFlagAction) {
                this.toggleFlag(r, c);
            } else {
                this.revealCell(r, c);
            }
        }
        this.draw();
    }

    toggleMode() {
        if (this.inputMode === 'DISARM') {
            this.inputMode = 'FLAG';
            this.modeBtn.innerText = "MODE: FLAG";
            this.modeBtn.classList.add('active');
        } else {
            this.inputMode = 'DISARM';
            this.modeBtn.innerText = "MODE: DISARM";
            this.modeBtn.classList.remove('active');
        }
    }

    // --- GAME LOGIC ---

    startIntro() {
        this.gameState = 'INTRO';
        this.drawIntro();
        const resumeText = this.currentLevelIdx > 0 ? `Resume Lvl ${this.currentLevelIdx + 1}` : "Clock In";
        this.updateDialogue("SYSTEM", `Tap screen to ${resumeText}. Don't be late.`);
    }

    startLevel(levelIdx) {
        this.currentLevelIdx = levelIdx;
        const config = this.levels[this.currentLevelIdx];
        
        this.GRID_SIZE = config.size;
        this.TOTAL_MINES = config.mines;
        this.CELL_SIZE = this.canvas.width / this.GRID_SIZE;

        this.gameState = 'PLAYING';
        this.grid = [];
        this.firstClick = true;
        this.flagsPlaced = 0;
        this.confettiParticles = [];
        cancelAnimationFrame(this.animationFrameId);

        this.levelDisplayEl.innerText = `LVL: ${config.level}/3 - ${config.name}`;
        this.updateDialogue("Zeke", config.zekeIntro);
        
        // Initialize Grid
        for (let r = 0; r < this.GRID_SIZE; r++) {
            let row = [];
            for (let c = 0; c < this.GRID_SIZE; c++) {
                row.push({
                    r, c,
                    isMine: false,
                    revealed: false,
                    flagged: false,
                    neighborCount: 0
                });
            }
            this.grid.push(row);
        }

        this.updateStats();
        this.draw();
    }

    placeMines(excludeR, excludeC) {
        let mines = 0;
        while (mines < this.TOTAL_MINES) {
            let r = Math.floor(Math.random() * this.GRID_SIZE);
            let c = Math.floor(Math.random() * this.GRID_SIZE);

            if (!this.grid[r][c].isMine && (r !== excludeR || c !== excludeC)) {
                this.grid[r][c].isMine = true;
                mines++;
            }
        }
        this.calculateNeighbors();
    }

    calculateNeighbors() {
        for (let r = 0; r < this.GRID_SIZE; r++) {
            for (let c = 0; c < this.GRID_SIZE; c++) {
                if (this.grid[r][c].isMine) continue;
                let count = 0;
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        let nr = r + i, nc = c + j;
                        if (nr >= 0 && nr < this.GRID_SIZE && nc >= 0 && nc < this.GRID_SIZE) {
                            if (this.grid[nr][nc].isMine) count++;
                        }
                    }
                }
                this.grid[r][c].neighborCount = count;
            }
        }
    }

    toggleFlag(r, c) {
        const cell = this.grid[r][c];
        if (cell.revealed) return;

        cell.flagged = !cell.flagged;
        this.flagsPlaced += cell.flagged ? 1 : -1;
        this.updateStats();
        
        if (cell.flagged && Math.random() > 0.8) {
            this.updateDialogue("Terry", "That looks like a HR violation.");
        }
    }

    revealCell(r, c) {
        const cell = this.grid[r][c];
        if (cell.revealed || cell.flagged) return;

        if (this.firstClick) {
            this.placeMines(r, c);
            this.firstClick = false;
        }

        cell.revealed = true;

        if (cell.isMine) {
            this.triggerGameOver(false);
        } else {
            if (cell.neighborCount === 0) {
                this.floodFill(r, c);
            }
            this.checkWinCondition();
        }
    }

    floodFill(r, c) {
        for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
                let nr = r + i, nc = c + j;
                if (nr >= 0 && nr < this.GRID_SIZE && nc >= 0 && nc < this.GRID_SIZE) {
                    let neighbor = this.grid[nr][nc];
                    if (!neighbor.revealed && !neighbor.flagged) {
                        this.revealCell(nr, nc);
                    }
                }
            }
        }
    }

    checkWinCondition() {
        let safeCellsUnrevealed = 0;
        for (let r = 0; r < this.GRID_SIZE; r++) {
            for (let c = 0; c < this.GRID_SIZE; c++) {
                if (!this.grid[r][c].isMine && !this.grid[r][c].revealed) {
                    safeCellsUnrevealed++;
                }
            }
        }

        if (safeCellsUnrevealed === 0) {
            this.handleLevelWin();
        }
    }

    handleLevelWin() {
        this.grid.flat().forEach(cell => { if(cell.isMine) cell.flagged = true; });
        this.updateStats();

        if (this.currentLevelIdx < this.levels.length - 1) {
            this.gameState = 'LEVEL_COMPLETE';
            this.updateDialogue("SYSTEM", `LEVEL COMPLETE. Performance: Adequate. Tap to proceed to ${this.levels[this.currentLevelIdx+1].name}.`);
            this.draw();
        } else {
            this.triggerGameOver(true);
        }
    }

    triggerGameOver(win) {
        if (win) {
            this.gameState = 'VICTORY';
            this.updateDialogue("Terry", "It's done. I'm going home.");
            setTimeout(() => this.updateDialogue("Zeke", "My mothership! It's ruined!"), 1500);
            setTimeout(() => this.updateDialogue("SYSTEM", "THREAT NEUTRALIZED. PIZZA PARTY AUTHORIZED."), 3000);
            this.startConfetti();
        } else {
            this.gameState = 'GAMEOVER';
            this.grid.flat().forEach(cell => { if(cell.isMine) cell.revealed = true; });
            this.draw();
            this.updateDialogue("Zeke", `BOOM! Try again? Tap screen to RETRY LEVEL ${this.currentLevelIdx + 1}.`);
        }
    }

    hardReset() {
        this.currentLevelIdx = 0;
        this.saveProgress();
        this.startIntro();
    }

    // --- VISUALS ---

    draw() {
        if (this.gameState === 'INTRO') {
            this.drawIntro();
            return;
        }

        // Clear
        this.ctx.fillStyle = "#c0c0c0";
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw Grid
        for (let r = 0; r < this.GRID_SIZE; r++) {
            for (let c = 0; c < this.GRID_SIZE; c++) {
                this.drawCell(r, c);
            }
        }

        // Overlay for Level Complete
        if (this.gameState === 'LEVEL_COMPLETE') {
            this.ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            this.drawText("LEVEL COMPLETE", this.canvas.width/2, this.canvas.height/2, "white", "bold 40px Courier New");
            this.drawText("Tap to Continue", this.canvas.width/2, this.canvas.height/2 + 50, "white", "20px Courier New");
        }
        
        // Overlay for Game Over
        if (this.gameState === 'GAMEOVER') {
             this.ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
             this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
             this.drawText("TERMINATED", this.canvas.width/2, this.canvas.height/2, "red", "bold 50px Courier New");
             this.drawText("Tap to Retry Level", this.canvas.width/2, this.canvas.height/2 + 60, "white", "24px Courier New");
        }
    }

    drawCell(r, c) {
        const cell = this.grid[r][c];
        const x = c * this.CELL_SIZE;
        const y = r * this.CELL_SIZE;
        const s = this.CELL_SIZE;

        if (!cell.revealed) {
            this.drawBevel(x, y, s, true);
            if (cell.flagged) {
                const fontSize = Math.floor(s * 0.6);
                this.drawText("ðŸš©", x + s/2, y + s/1.5, "black", `${fontSize}px Arial`);
            }
        } else {
            this.ctx.strokeStyle = "#808080";
            this.ctx.strokeRect(x, y, s, s);
            
            if (cell.isMine) {
                if (this.gameState === 'GAMEOVER') this.ctx.fillStyle = "red";
                else this.ctx.fillStyle = "#c0c0c0";
                
                this.ctx.fillRect(x+1, y+1, s-2, s-2);
                const fontSize = Math.floor(s * 0.6);
                this.drawText("ðŸ’£", x + s/2, y + s/1.5, "black", `${fontSize}px Arial`);
            } else if (cell.neighborCount > 0) {
                const fontSize = Math.floor(s * 0.8);
                this.drawText(
                    cell.neighborCount, 
                    x + s/2, 
                    y + s/1.3, 
                    this.colors[cell.neighborCount],
                    `bold ${fontSize}px Courier New`
                );
            }
        }
    }

    drawBevel(x, y, size, raised) {
        const light = "#ffffff";
        const shadow = "#808080";
        const face = "#c0c0c0";

        this.ctx.fillStyle = face;
        this.ctx.fillRect(x, y, size, size);

        // Simple Bevel
        const b = Math.floor(size * 0.1); 
        
        this.ctx.fillStyle = raised ? light : shadow;
        this.ctx.beginPath();
        this.ctx.moveTo(x, y);
        this.ctx.lineTo(x + size, y);
        this.ctx.lineTo(x, y + size);
        this.ctx.fill();

        this.ctx.fillStyle = raised ? shadow : light;
        this.ctx.beginPath();
        this.ctx.moveTo(x + size, y + size);
        this.ctx.lineTo(x + size, y);
        this.ctx.lineTo(x, y + size);
        this.ctx.fill();

        this.ctx.fillStyle = face;
        this.ctx.fillRect(x + b, y + b, size - (2*b), size - (2*b));
    }

    drawIntro() {
        this.ctx.fillStyle = "#c0c0c0";
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        const memoW = 400;
        const memoH = 420;
        const startX = (this.canvas.width - memoW) / 2;
        const startY = (this.canvas.height - memoH) / 2;

        this.ctx.fillStyle = "rgba(0,0,0,0.5)";
        this.ctx.fillRect(startX + 8, startY + 8, memoW, memoH);

        this.ctx.fillStyle = "#ffffff";
        this.ctx.fillRect(startX, startY, memoW, memoH);
        this.ctx.strokeStyle = "#808080";
        this.ctx.lineWidth = 2;
        this.ctx.strokeRect(startX, startY, memoW, memoH);

        this.ctx.fillStyle = "#000080";
        this.ctx.fillRect(startX, startY, memoW, 40);
        
        this.ctx.fillStyle = "#ffffff";
        this.ctx.font = "bold 18px Courier New";
        this.ctx.textAlign = "left";
        this.ctx.fillText("INCOMING TRANSMISSION", startX + 15, startY + 26);

        this.ctx.fillStyle = "black";
        this.ctx.font = "14px Courier New"; 
        
        let lines = [
            "FROM: HUMAN RESOURCES",
            "TO: TERRY (JUNIOR ASSOC.)",
            "RE: URGENT - ALIEN INVASION",
            "---------------------------",
            "Terry,",
            "",
            "An alien entity 'ZEKE' has",
            "placed 'Quantum Destabilizers'",
            "in the office grid.",
            "",
            "Please disarm them.",
            "",
            "NOTE: Progress is Saved.",
            "Long Press to Flag.",
            "",
            "[TAP TO CLOCK IN]"
        ];

        let currentY = startY + 70;
        lines.forEach(line => {
            this.ctx.fillText(line, startX + 20, currentY);
            currentY += 20;
        });
    }

    drawText(text, x, y, color, font) {
        this.ctx.fillStyle = color;
        this.ctx.font = font;
        this.ctx.textAlign = "center";
        this.ctx.fillText(text, x, y);
    }

    updateStats() {
        this.minesLeftEl.innerText = `HAZARDS: ${Math.max(0, this.TOTAL_MINES - this.flagsPlaced)}`;
    }

    updateDialogue(speaker, text) {
        let cssClass = "";
        if (speaker === "Zeke") cssClass = "speaker-zeke";
        else if (speaker === "Terry") cssClass = "speaker-terry";
        else cssClass = "speaker-sys";
        this.dialogueEl.innerHTML = `<span class="${cssClass}">${speaker}:</span> "${text}"`;
        this.dialogueEl.scrollTop = this.dialogueEl.scrollHeight;
    }

    startConfetti() {
        this.confettiParticles = [];
        for (let i = 0; i < 150; i++) {
            this.confettiParticles.push({
                x: this.canvas.width / 2,
                y: this.canvas.height / 2,
                vx: (Math.random() - 0.5) * 15,
                vy: (Math.random() - 0.5) * 15 - 5,
                size: Math.random() * 8 + 4,
                color: `hsl(${Math.random() * 360}, 100%, 50%)`,
                drag: 0.96,
                gravity: 0.2
            });
        }
        this.animateConfetti();
    }

    animateConfetti() {
        if (this.gameState !== 'VICTORY') return;
        this.draw(); 
        this.confettiParticles.forEach(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.vy += p.gravity;
            p.vx *= p.drag;
            this.ctx.fillStyle = p.color;
            this.ctx.fillRect(p.x, p.y, p.size, p.size);
        });
        this.animationFrameId = requestAnimationFrame(() => this.animateConfetti());
    }
}

const game = new GameEngine();

</script>
</body>
</html>
